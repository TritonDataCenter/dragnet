#!/usr/bin/env node

/*
 * dn: create, query, and destroy indexes on data stored in Manta
 */

var mod_bunyan = require('bunyan');
var mod_jsprim = require('jsprim');
var mod_path = require('path');
var mod_vasync = require('vasync');
var OptionParser = require('posix-getopt').BasicParser;
var VError = require('verror');

var mod_streamutil = require('../lib/stream-util');
var schemaIndex = require('../schema/user-index');
var schemaQuery = require('../schema/user-query');
var LocalDataStore = require('../lib/datastore-local');
var JsonLineStream = require('../lib/format-json');
var QueryScanner = require('../lib/query-scan');

var dnArg0 = mod_path.basename(process.argv[1]);
var dnCmds = {
    'index': cmdIndex,
    'destroy': cmdDestroy,
    'query': cmdQuery,
    'scan': cmdScan
};
var dnUsage = [
    'usage: dn index INDEX_CONFIG_FILE\n',
    '       dn destroy INDEX_NAME\n',
    '       dn query INDEX_NAME QUERY_CONFIG_FILE ...\n',
    '       dn scan INDEX_CONFIG_FILE QUERY_CONFIG_FILE'
].join('');
var dnLog;

function usage(err)
{
	if (err)
		console.error('%s: %s', dnArg0, err.message);

	console.error(dnUsage);
	process.exit(2);
}

function fatal(err)
{
	console.error('%s: %s', dnArg0, err.message);
	process.exit(1);
}

function main()
{
	var cmdname, cmdfunc;

	if (process.argv.length < 3)
		usage();

	cmdname = process.argv[2];
	if (!dnCmds.hasOwnProperty(cmdname))
		usage(new VError('no such command: "%s"', cmdname));

	dnLog = new mod_bunyan({
	    'name': 'dragnet',
	    'level': process.env['LOG_LEVEL'] || 'warn'
	});
	cmdfunc = dnCmds[cmdname];
	cmdfunc(cmdname, process.argv.slice(3));
}

function cmdIndex(cmdname, argv)
{
	console.log('"%s" not yet implemented', cmdname);
}

function cmdDestroy(cmdname, argv)
{
	console.log('"%s" not yet implemented', cmdname);
}

function cmdQuery(cmdname, argv)
{
	console.log('"%s" not yet implemented', cmdname);
}

function cmdScan(cmdname, argv)
{
	var indexname, indexConf;
	var optparser, option;
	var queryConf = {
	    'breakdowns': []
	};

	argv.unshift('', '');
	optparser = new OptionParser(':f:(filter)b:(breakdowns)', argv);
	while ((option = optparser.getopt()) !== undefined) {
		switch (option.option) {
		case 'f':
			try {
				queryConf.filter = JSON.parse(option.optarg);
			} catch (ex) {
				usage(new VError(ex, 'invalid filter'));
			}
			break;

		case 'b':
			var fields = option.optarg.split(',');
			queryConf.breakdowns =
			    queryConf.breakdowns.concat(fields);
			break;

		default:
			usage();
			break;
		}
	}

	if (optparser.optind() == argv.length)
		usage();

	indexname = argv[optparser.optind()];
	mod_vasync.waterfall([
	    function (callback) {
		mod_streamutil.readFileJson({
		    'filename': indexname,
		    'schema': schemaIndex
		}, callback);
	    },
	    function (conf, callback) {
		indexConf = conf;
		queryConf.index = indexConf.name;
		var err = mod_jsprim.validateJsonObject(schemaQuery, queryConf);
		callback(err);
	    }
	], function (err) {
		if (err)
			fatal(err);

		if (!indexConf.hasOwnProperty('fsroot'))
			err = new VError('expected "fsroot"');
		else if (indexConf.format != 'json')
			err = new VError('only "json" format is supported');

		if (err)
			fatal(err);

		var datastore, source, parser, scanner;

		datastore = new LocalDataStore({
		    'log': dnLog,
		    'fsroot': indexConf.fsroot
		});
		source = datastore.stream();
		source.on('err', fatal);

		parser = new JsonLineStream();
		source.pipe(parser);

		scanner = new QueryScanner({
		    'log': dnLog,
		    'index': indexConf,
		    'query': queryConf
		});
		parser.pipe(scanner);

		scanner.on('data', function (result) {
			console.log(JSON.stringify(result, null, '\t'));
		});
	});
}

main();
