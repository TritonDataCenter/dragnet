#!/usr/bin/env node
/* vim: set syn=javascript: */

/*
 * dn: create, query, and destroy indexes on data stored in Manta
 */

var timeStarted = process.hrtime();
var mod_assert = require('assert');
var mod_bunyan = require('bunyan');
var mod_jsprim = require('jsprim');
var mod_path = require('path');
var mod_tab = require('tab');
var OptionParser = require('posix-getopt').BasicParser;
var VError = require('verror');
var sprintf = require('extsprintf').sprintf;

var mod_dragnet = require('../lib/dragnet');
var mod_dragnet_impl = require('../lib/dragnet-impl'); /* XXX */
var FileDataSource = require('../lib/source-file');
var FileSetDataSource = require('../lib/source-fileset');
var SkinnerFlattener = require('../lib/skinner-flattener');

var timeRequireDone = process.hrtime(timeStarted);

var dnArg0 = mod_path.basename(process.argv[1]);
var dnCmds = {
    'index': cmdIndex,
    'query': cmdQuery,
    'scan': cmdScan
};
var dnUsage = [
    'usage: dn index INDEX_OPTIONS FILENAME INDEX_FILENAME\n',
    '       dn scan  QUERY_OPTIONS FILENAME\n',
    '       dn query QUERY_OPTIONS INDEX_FILENAME'
].join('');
var dnDone = false;
var dnTimeField = 'time'; /* XXX */
var dnTrackTime = false;
var dnLog;

function usage(err)
{
	if (err)
		console.error('%s: %s', dnArg0, err.message);

	dnDone = true;
	console.error(dnUsage);
	process.exit(2);
}

function fatal(err)
{
	dnDone = true;
	console.error('%s: %s', dnArg0, err.message);
	process.exit(1);
}

function main()
{
	var optind, cmdname, cmdfunc;

	optind = 2;
	if (process.argv[optind] == '-t') {
		dnTrackTime = true;
		optind++;
	}

	if (process.argv.length < optind + 1)
		usage();

	cmdname = process.argv[optind];
	if (!dnCmds.hasOwnProperty(cmdname))
		usage(new VError('no such command: "%s"', cmdname));

	dnLog = new mod_bunyan({
	    'name': 'dragnet',
	    'level': process.env['LOG_LEVEL'] || 'warn'
	});

	process.stdout.on('error', function (err) {
		if (err.code == 'EPIPE') {
			dnDone = true;
			process.exit(0);
		}
		throw (err);
	});
	cmdfunc = dnCmds[cmdname];
	cmdfunc(cmdname, process.argv.slice(optind + 1));
}

function cmdIndex(cmdname, argv)
{
	var optparser, option, optind;
	var indexConf = {
	    'columns': [],
	    'resolution': 'hour'
	};
	var showinvalid = false;
	var showcounters = false;
	var sourceclass, sourceargs;
	var source, index, indexop;
	var indexargs;

	sourceargs = { 'log': dnLog };
	indexargs = {};
	argv.unshift('', '');
	optparser = new OptionParser(':c:(columns)f:(filter)C(counters)' +
	    'I:(indexroot)R:(dataroot)S(show-invalid)', argv);
	while ((option = optparser.getopt()) !== undefined) {
		switch (option.option) {
		case 'c':
			var fields = option.optarg.split(',');
			indexConf.columns =
			    indexConf.columns.concat(fields);
			break;

		case 'f':
			try {
				indexConf.filter = JSON.parse(option.optarg);
			} catch (ex) {
				usage(new VError(ex, 'invalid filter'));
			}
			break;

		case 'C':
			showcounters = true;
			break;

		case 'I':
			indexargs['indexroot'] = option.optarg;
			break;

		case 'R':
			sourceclass = FileSetDataSource;
			sourceargs['dataroot'] = option.optarg;
			break;

		case 'S':
			showinvalid = true;
			break;

		default:
			usage();
			break;
		}
	}

	optind = optparser.optind();
	if (sourceclass === undefined) {
		if (optparser.optind() != argv.length - 2)
			usage();
		sourceclass = FileDataSource;
		sourceargs['filename'] = argv[optind++];
		indexargs['filename'] = argv[optind++];

		if (indexargs.hasOwnProperty('indexroot')) {
			console.error('warn: -I/--indexroot is ignored for ' +
			    'file-based indexes');
		}
	} else {
		if (optparser.optind() != argv.length)
			usage();

		if (!indexargs.hasOwnProperty('indexroot'))
			indexargs['indexroot'] = inferIndexRoot(
			    sourceargs['dataroot']);
	}

	source = new sourceclass(sourceargs);
	index = mod_dragnet.indexLoad({ 'index': indexConf });
	if (index instanceof Error)
		fatal(index);

	indexargs['index'] = index;
	indexargs['format'] = 'json';
	indexargs['timeField'] = dnTimeField;
	indexop = source.index(indexargs);
	indexop.on('error', fatal);

	if (showinvalid) {
		indexop.on('invalid_record', function (str, perr, idx) {
			console.error('warn: bad record at line %d: %s',
			    idx, perr.toString());
			console.error('      input: %s', str);
		});

		indexop.on('invalid_object', function (obj, perr, idx) {
			console.error('warn: bad object at line %d: %s',
			    idx, perr.message);
			console.error('      input: %s', JSON.stringify(obj));
		});
	}

	indexop.on('finish', function () {
		if (indexargs['filename']) {
			console.error('index "%s" created',
			    indexargs['filename']);
		}

		cmdScanPrintCounters(indexop.stats(), showcounters);
		dnDone = true;
	});
}

function cmdQuery(cmdname, argv)
{
	var optparser, option;
	var queryConf = {
	    'breakdowns': []
	};
	var output = cmdScanOutputPretty;
	var query, queryargs, results, stream;
	var source, sourceclass, sourceargs;

	sourceargs = { 'log': dnLog };
	queryargs = {};
	argv.unshift('', '');
	optparser = new OptionParser(':b:(breakdowns)f:(filter)r(raw)' +
	    'I:(indexroot)R:(root)', argv);
	while ((option = optparser.getopt()) !== undefined) {
		switch (option.option) {
		case 'f':
			try {
				queryConf.filter = JSON.parse(option.optarg);
			} catch (ex) {
				usage(new VError(ex, 'invalid filter'));
			}
			break;

		case 'b':
			var fields = option.optarg.split(',');
			queryConf.breakdowns =
			    queryConf.breakdowns.concat(fields);
			break;

		case 'r':
			output = cmdScanOutputRaw;
			break;

		case 'I':
			sourceclass = FileSetDataSource;
			if (!sourceargs['dataroot']) {
				/*
				 * XXX should dataroot/filename arguments just
				 * be passed into scan() rather than the
				 * constructor so that they're only used when
				 * needed?
				 */
				sourceargs['dataroot'] = 'unused';
			}
			queryargs['indexroot'] = option.optarg;
			break;

		case 'R':
			sourceclass = FileSetDataSource;
			sourceargs['dataroot'] = option.optarg;
			break;

		default:
			usage();
			break;
		}
	}

	if (sourceclass === undefined) {
		if (optparser.optind() != argv.length - 1)
			usage();

		sourceclass = FileDataSource;
		sourceargs['filename'] = 'unused'; /* XXX see above */
		queryargs['filename'] = argv[optparser.optind()];
	} else {
		if (optparser.optind() != argv.length)
			usage();

		if (!queryargs.hasOwnProperty('indexroot'))
			queryargs['indexroot'] = inferIndexRoot(
			    sourceargs['dataroot']);
	}

	query = mod_dragnet.queryLoad({ 'query': queryConf });
	if (query instanceof Error)
		fatal(query);

	queryargs['query'] = query;
	source = new sourceclass(sourceargs);
	stream = new SkinnerFlattener({
	    'skinnerOptions': mod_dragnet_impl.queryAggrStreamConfig({
	        'query': query
	    })
	});
	results = source.query(queryargs);
	results.pipe(stream);

	stream.on('data', function (rows) {
		output({
		    'rows': rows,
		    'columns': query.qc_breakdowns,
		    'bucketizers': query.qc_bucketizers
		});
	});

	stream.on('end', function () {
		dnDone = true;
	});
}

function cmdScan(cmdname, argv)
{
	var optparser, option;
	var queryConf = {
	    'breakdowns': []
	};
	var output = cmdScanOutputPretty;
	var showinvalid = false;
	var showcounters = false;
	var aspoints = false;
	var sourceclass, sourceargs;
	var source, query, scan, stream, tail;

	sourceargs = { 'log': dnLog };
	argv.unshift('', '');
	optparser = new OptionParser(':b:(breakdowns)f:(filter)p(points)' +
	    'r(raw)C(counters)R:(root)S(show-invalid)', argv);
	while ((option = optparser.getopt()) !== undefined) {
		switch (option.option) {
		case 'f':
			try {
				queryConf.filter = JSON.parse(option.optarg);
			} catch (ex) {
				usage(new VError(ex, 'invalid filter'));
			}
			break;

		case 'b':
			var fields = option.optarg.split(',');
			queryConf.breakdowns =
			    queryConf.breakdowns.concat(fields);
			break;

		case 'p':
			output = cmdScanOutputRaw;
			aspoints = true;
			break;

		case 'r':
			output = cmdScanOutputRaw;
			break;

		case 'C':
			showcounters = true;
			break;

		case 'R':
			sourceclass = FileSetDataSource;
			sourceargs['dataroot'] = option.optarg;
			break;

		case 'S':
			showinvalid = true;
			break;

		default:
			usage();
			break;
		}
	}

	if (sourceclass === undefined) {
		if (optparser.optind() != argv.length - 1)
			usage();
		sourceclass = FileDataSource;
		sourceargs['filename'] = argv[optparser.optind()];
	}

	source = new sourceclass(sourceargs);
	query = mod_dragnet.queryLoad({ 'query': queryConf });
	if (query instanceof Error)
		fatal(query);

	scan = source.scan({
	    'query': query,
	    'format': 'json',
	    'timeField': dnTimeField
	});
	scan.on('error', fatal);

	if (showinvalid) {
		scan.on('invalid_record', function (str, perr, idx) {
			console.error('warn: bad record at line %d: %s',
			    idx, perr.toString());
			console.error('      input: %s', str);
		});

		scan.on('invalid_object', function (obj, perr, idx) {
			console.error('warn: bad object at line %d: %s',
			    idx, perr.message);
			console.error('      input: %s', JSON.stringify(obj));
		});
	}

	if (aspoints) {
		tail = scan;
	} else {
		stream = new SkinnerFlattener({
		    'skinnerOptions': mod_dragnet_impl.queryAggrStreamConfig({
		        'query': query
		    })
		});
		scan.pipe(stream);
		tail = stream;
	}

	tail.on('data', function (rows) {
		output({
		    'rows': rows,
		    'columns': query.qc_breakdowns,
		    'bucketizers': query.qc_bucketizers
		});
	});

	tail.on('end', function () {
		cmdScanPrintCounters(scan.stats(), showcounters);
		dnDone = true;
	});
}

function cmdScanOutputRaw(results)
{
	console.log(JSON.stringify(results.rows, null, '\t'));
}

function cmdScanOutputPretty(results)
{
	var coldefs, tablefields;

	coldefs = results.columns;
	if (coldefs.length > 0 && coldefs[coldefs.length - 1].aggr) {
		cmdScanOutputPrettyQuantized(results);
		return;
	}

	tablefields = coldefs.map(function (c) {
		return ({
		    'label': c.name.toUpperCase(),
		    'width': c.name.toUpperCase().toString().length
		});
	});
	tablefields.push({
	    'label': 'VALUE',
	    'width': 'VALUE'.length,
	    'align': 'right'
	});

	if (results.rows.length === 0)
		return;

	/*
	 * Take a pass over the results and replace quantized values with the
	 * real values.
	 */
	coldefs.forEach(function (c, j) {
		if (!results.bucketizers.hasOwnProperty(c.name))
			return;

		var bucketizer = results.bucketizers[c.name];
		results.rows.forEach(function (row) {
			row[j] = bucketizer.bucketMin(row[j]);
		});
	});

	if (results.rows.length == 1 && typeof (results.rows[0]) == 'number')
		results.rows[0] = [ results.rows[0] ];

	results.rows.forEach(function (row) {
		var width;

		mod_assert.ok(row.length == coldefs.length + 1);
		coldefs.forEach(function (c, j) {
			if (typeof (row[j]) == 'number')
				tablefields[j].align = 'right';
			else
				mod_assert.equal('string', typeof (row[j]));

			width = row[j].toString().length;
			if (tablefields[j].width < width)
				tablefields[j].width = width;
		});

		mod_assert.equal('number', typeof (row[row.length - 1]));
		width = row[row.length - 1].toString().length;
		if (tablefields[row.length - 1].width < width)
			tablefields[row.length - 1].width = width;
	});

	mod_tab.emitTable({
	    'columns': tablefields,
	    'rows': results.rows.slice(0).sort(function (a, b) {
		var j, d;

		mod_assert.ok(Array.isArray(a) && Array.isArray(b));
		mod_assert.equal(a.length, b.length);
		for (j = 0; j < a.length; j++) {
			if (typeof (a[j]) == 'string')
				d = a[j].localeCompare(b[j]);
			else
				d = a[j] - b[j];

			if (d !== 0)
				return (d);
		}

		return (0);
	    })
	});
}

function cmdScanOutputPrettyQuantized(results)
{
	var coldefs, quantizedcol, stream, bucketizer, last, distr;

	coldefs = results.columns;
	quantizedcol = coldefs[coldefs.length - 1];
	mod_assert.equal(typeof (quantizedcol.aggr), 'string');
	bucketizer = results.bucketizers[quantizedcol.name];
	mod_assert.ok(bucketizer !== null);
	stream = process.stdout;
	last = null;
	distr = [];

	results.rows.forEach(function (row) {
		var discrete_values = row.slice(0, coldefs.length - 1);
		var key = discrete_values.join(', ') + '\n';
		if (distr.length > 0 && key !== last) {
			stream.write(last);
			printDistribution(stream, distr, bucketizer);
			stream.write('\n');
		}
		if (key !== last) {
			last = key;
			distr = [];
		}

		distr.push([ row[coldefs.length - 1], row[coldefs.length] ]);
	});

	stream.write(last);
	printDistribution(stream, distr, bucketizer);
}

function printDistribution(stream, distr, bucketizer)
{
	var total, count, normalized, dots;
	var bi, di, i, min;

	stream.write('           ');
	stream.write(
	    'value  ------------- Distribution ------------- count\n');

	if (distr.length === 0)
		return;

	total = 0;
	for (di = 0; di < distr.length; di++)
		total += distr[di][1];

	/*
	 * If there's a large number of empty buckets at the beginning, we're
	 * probably lookint at large values (like timestamps) where the user
	 * doesn't really want us to print all the leading empty buckets.
	 */
	if (distr[0][0] > 100)
		bi = distr[0][0];
	else
		bi = 0;

	for (di = 0; di < distr.length + 1; bi++) {
		if (di == distr.length) {
			count = 0;
			di++;
		} else if (distr[di][0] == bi) {
			count = distr[di][1];
			di++;
		} else {
			count = 0;
		}

		normalized = Math.round(40 * count / total);
		dots = '';
		for (i = 0; i < normalized; i++)
			dots += '@';
		for (; i < 40; i++)
			dots += ' ';

		min = bucketizer.bucketMin(bi);
		stream.write(sprintf('%16s |%s %s\n',
		    min.toString(), dots, count));
	}
}

function cmdScanPrintCounters(c, showall)
{
	if (!showall) {
		if (c.aggr_nerr_nonnumeric !== 0) {
			console.error('warn: ignored %d non-numeric values',
			    c.aggr_nerr_nonnumeric);
		}

		return;
	}

	var width, fmt;
	mod_jsprim.forEachKey(c, function (name, value) {
		if (width === undefined || width < name.length)
			width = name.length;
	});
	fmt = '%-' + (width + 1) + 's  %d';
	mod_jsprim.forEachKey(c, function (name, value) {
		console.error(sprintf(fmt, name + ':', value));
	});
}

function inferIndexRoot(dataroot)
{
	var resolved, basename, indexroot;

	resolved = mod_path.resolve(dataroot);
	basename = mod_path.basename(resolved);
	indexroot = mod_path.join(dataroot, '..', basename + '_index');
	console.error('inferring index root: %s', indexroot);
	return (indexroot);
}

process.on('exit', function () {
	if (dnTrackTime) {
		var timeDone = process.hrtime(timeStarted);
		console.error('timing stats:');
		console.error('    require: ', timeRequireDone);
		console.error('    total:   ', timeDone);
	}

	mod_assert.ok(dnDone, 'premature exit');
});

main();
