#!/usr/bin/env node
/* vim: set syn=javascript: */

/*
 * dn: create, query, and destroy indexes on data stored in Manta
 */

var mod_assert = require('assert');
var mod_bunyan = require('bunyan');
var mod_jsprim = require('jsprim');
var mod_path = require('path');
var mod_tab = require('tab');
var OptionParser = require('posix-getopt').BasicParser;
var VError = require('verror');
var sprintf = require('extsprintf').sprintf;

var mod_dragnet = require('../lib/dragnet');
var mod_dragnet_impl = require('../lib/dragnet-impl'); /* XXX */
var FileDataSource = require('../lib/source-file');
var FileSetDataSource = require('../lib/source-fileset');
var QueryIndex = require('../lib/query-index');
var SkinnerFlattener = require('../lib/skinner-flattener');

var dnArg0 = mod_path.basename(process.argv[1]);
var dnCmds = {
    'index': cmdIndex,
    'query': cmdQuery,
    'scan': cmdScan
};
var dnUsage = [
    'usage: dn index INDEX_OPTIONS FILENAME INDEX_FILENAME\n',
    '       dn scan  QUERY_OPTIONS FILENAME\n',
    '       dn query QUERY_OPTIONS INDEX_FILENAME'
].join('');
var dnDone = false;
var dnLog;

function usage(err)
{
	if (err)
		console.error('%s: %s', dnArg0, err.message);

	console.error(dnUsage);
	process.exit(2);
}

function fatal(err)
{
	console.error('%s: %s', dnArg0, err.message);
	process.exit(1);
}

function main()
{
	var cmdname, cmdfunc;

	if (process.argv.length < 3)
		usage();

	cmdname = process.argv[2];
	if (!dnCmds.hasOwnProperty(cmdname))
		usage(new VError('no such command: "%s"', cmdname));

	dnLog = new mod_bunyan({
	    'name': 'dragnet',
	    'level': process.env['LOG_LEVEL'] || 'warn'
	});

	process.stdout.on('error', function (err) {
		if (err.code == 'EPIPE')
			process.exit(0);
		throw (err);
	});
	cmdfunc = dnCmds[cmdname];
	cmdfunc(cmdname, process.argv.slice(3));
}

function cmdIndex(cmdname, argv)
{
	var optparser, option, optind;
	var indexConf = {
	    'columns': [],
	    'resolution': 'hour'
	};
	var showinvalid = false;
	var showcounters = false;
	var sourceclass, sourceargs;
	var source, index, indexop;
	var indexargs;

	sourceargs = { 'log': dnLog };
	indexargs = {};
	argv.unshift('', '');
	optparser = new OptionParser(':c:(columns)f:(filter)C(counters)' +
	    'I:(indexroot)R:(dataroot)S(show-invalid)', argv);
	while ((option = optparser.getopt()) !== undefined) {
		switch (option.option) {
		case 'c':
			var fields = option.optarg.split(',');
			indexConf.columns =
			    indexConf.columns.concat(fields);
			break;

		case 'f':
			try {
				indexConf.filter = JSON.parse(option.optarg);
			} catch (ex) {
				usage(new VError(ex, 'invalid filter'));
			}
			break;

		case 'C':
			showcounters = true;
			break;

		case 'I':
			indexargs['indexroot'] = option.optarg;
			break;

		case 'R':
			sourceclass = FileSetDataSource;
			sourceargs['dataroot'] = option.optarg;
			break;

		case 'S':
			showinvalid = true;
			break;

		default:
			usage();
			break;
		}
	}

	optind = optparser.optind();
	if (sourceclass === undefined) {
		if (optparser.optind() != argv.length - 2)
			usage();
		sourceclass = FileDataSource;
		sourceargs['filename'] = argv[optind++];
		indexargs['filename'] = argv[optind++];

		if (indexargs.hasOwnProperty('indexroot')) {
			console.error('warn: -I/--indexroot is ignored for ' +
			    'file-based indexes');
		}
	} else {
		if (optparser.optind() != argv.length)
			usage();

		if (!indexargs.hasOwnProperty('indexroot')) {
			var databasename = mod_path.basename(
			    mod_path.resolve(sourceargs['dataroot']));
			indexargs['indexroot'] = mod_path.join(
			    sourceargs['dataroot'], '../',
			    databasename + '_index');
			console.error('inferring index root: %s',
			    indexargs['indexroot']);
		}
	}

	source = new sourceclass(sourceargs);

	index = mod_dragnet.indexLoad({ 'index': indexConf });
	if (index instanceof Error)
		fatal(index);

	indexargs['index'] = index;
	indexargs['format'] = 'json';
	indexop = source.index(indexargs);
	indexop.on('error', fatal);

	if (showinvalid) {
		indexop.on('invalid_record', function (str, perr, idx) {
			console.error('warn: bad record at line %d: %s',
			    idx, perr.toString());
			console.error('      input: %s', str);
		});

		indexop.on('invalid_object', function (obj, perr, idx) {
			console.error('warn: bad object at line %d: %s',
			    idx, perr.message);
			console.error('      input: %s', JSON.stringify(obj));
		});
	}

	indexop.on('finish', function () {
		if (indexargs['filename']) {
			console.error('index "%s" created',
			    indexargs['filename']);
		}

		cmdScanPrintCounters(indexop.stats(), showcounters);
		dnDone = true;
	});
}

function cmdQuery(cmdname, argv)
{
	var indexfile;
	var optparser, option;
	var queryConf = {
	    'breakdowns': []
	};
	var output = cmdScanOutputPretty;
	var query, queryindex;

	argv.unshift('', '');
	optparser = new OptionParser(':b:(breakdowns)f:(filter)r(raw)', argv);
	while ((option = optparser.getopt()) !== undefined) {
		switch (option.option) {
		case 'f':
			try {
				queryConf.filter = JSON.parse(option.optarg);
			} catch (ex) {
				usage(new VError(ex, 'invalid filter'));
			}
			break;

		case 'b':
			var fields = option.optarg.split(',');
			queryConf.breakdowns =
			    queryConf.breakdowns.concat(fields);
			break;

		case 'r':
			output = cmdScanOutputRaw;
			break;

		default:
			usage();
			break;
		}
	}

	if (optparser.optind() != argv.length - 1)
		usage();

	indexfile = argv[optparser.optind()];
	query = mod_dragnet.queryLoad({ 'query': queryConf });
	if (query instanceof Error)
		fatal(query);

	queryindex = new QueryIndex({
	    'log': dnLog,
	    'filename': indexfile
	});
	queryindex.on('error', fatal);
	queryindex.on('ready', function () {
		queryindex.run(query, function (qerr, rows) {
			if (qerr)
				fatal(qerr);

			output({
			    'rows': rows,
			    'columns': query.qc_breakdowns,
			    'bucketizers': query.qc_bucketizers
			});
			dnDone = true;
		});
	});
}

function cmdScan(cmdname, argv)
{
	var optparser, option;
	var queryConf = {
	    'breakdowns': []
	};
	var output = cmdScanOutputPretty;
	var showinvalid = false;
	var showcounters = false;
	var aspoints = false;
	var sourceclass, sourceargs;
	var source, query, scan, stream, tail;

	sourceargs = { 'log': dnLog };
	argv.unshift('', '');
	optparser = new OptionParser(':b:(breakdowns)f:(filter)p(points)' +
	    'r(raw)C(counters)R:(root)S(show-invalid)', argv);
	while ((option = optparser.getopt()) !== undefined) {
		switch (option.option) {
		case 'f':
			try {
				queryConf.filter = JSON.parse(option.optarg);
			} catch (ex) {
				usage(new VError(ex, 'invalid filter'));
			}
			break;

		case 'b':
			var fields = option.optarg.split(',');
			queryConf.breakdowns =
			    queryConf.breakdowns.concat(fields);
			break;

		case 'p':
			output = cmdScanOutputRaw;
			aspoints = true;
			break;

		case 'r':
			output = cmdScanOutputRaw;
			break;

		case 'C':
			showcounters = true;
			break;

		case 'R':
			sourceclass = FileSetDataSource;
			sourceargs['dataroot'] = option.optarg;
			break;

		case 'S':
			showinvalid = true;
			break;

		default:
			usage();
			break;
		}
	}

	if (sourceclass === undefined) {
		if (optparser.optind() != argv.length - 1)
			usage();
		sourceclass = FileDataSource;
		sourceargs['filename'] = argv[optparser.optind()];
	}

	source = new sourceclass(sourceargs);

	query = mod_dragnet.queryLoad({ 'query': queryConf });
	if (query instanceof Error)
		fatal(query);

	scan = source.scan({
	    'query': query,
	    'format': 'json',
	    'timeField': 'time' /* XXX */
	});
	scan.on('error', fatal);

	if (showinvalid) {
		scan.on('invalid_record', function (str, perr, idx) {
			console.error('warn: bad record at line %d: %s',
			    idx, perr.toString());
			console.error('      input: %s', str);
		});

		scan.on('invalid_object', function (obj, perr, idx) {
			console.error('warn: bad object at line %d: %s',
			    idx, perr.message);
			console.error('      input: %s', JSON.stringify(obj));
		});
	}

	if (aspoints) {
		tail = scan;
	} else {
		stream = new SkinnerFlattener({
		    'skinnerOptions': mod_dragnet_impl.queryAggrStreamConfig({
		        'query': query
		    })
		});
		scan.pipe(stream);
		tail = stream;
	}

	tail.on('data', function (rows) {
		output({
		    'rows': rows,
		    'columns': query.qc_breakdowns,
		    'bucketizers': query.qc_bucketizers
		});
	});

	tail.on('end', function () {
		cmdScanPrintCounters(scan.stats(), showcounters);
		dnDone = true;
	});
}

function cmdScanOutputRaw(results)
{
	console.log(JSON.stringify(results.rows, null, '\t'));
}

function cmdScanOutputPretty(results)
{
	var hasquantize = false;
	var coldefs, i, tablefields;

	coldefs = results.columns;

	for (i = 0; i < coldefs.length; i++) {
		if (coldefs[i].aggr) {
			hasquantize = true;
			break;
		}
	}

	if (hasquantize) {
		cmdScanOutputPrettyQuantized(results);
		return;
	}

	tablefields = coldefs.map(function (c) {
		return ({
		    'label': c.name.toUpperCase(),
		    'width': c.name.toUpperCase().toString().length
		});
	});
	tablefields.push({
	    'label': 'VALUE',
	    'width': 'VALUE'.length,
	    'align': 'right'
	});

	if (results.rows.length === 0)
		return;

	if (results.rows.length == 1 && typeof (results.rows[0]) == 'number')
		results.rows[0] = [ results.rows[0] ];

	results.rows.forEach(function (row) {
		var width;

		mod_assert.ok(row.length == coldefs.length + 1);
		coldefs.forEach(function (c, j) {
			if (typeof (row[j]) == 'number')
				tablefields[j].align = 'right';
			else
				mod_assert.equal('string', typeof (row[j]));

			width = row[j].toString().length;
			if (tablefields[j].width < width)
				tablefields[j].width = width;
		});

		mod_assert.equal('number', typeof (row[row.length - 1]));
		width = row[row.length - 1].toString().length;
		if (tablefields[row.length - 1].width < width)
			tablefields[row.length - 1].width = width;
	});

	mod_tab.emitTable({
	    'columns': tablefields,
	    'rows': results.rows.slice(0).sort(function (a, b) {
		var j, d;

		mod_assert.ok(Array.isArray(a) && Array.isArray(b));
		mod_assert.equal(a.length, b.length);
		for (j = 0; j < a.length; j++) {
			if (typeof (a[j]) == 'string')
				d = a[j].localeCompare(b[j]);
			else
				d = b[j] - a[j];

			if (d !== 0)
				return (d);
		}

		return (0);
	    })
	});
}

function cmdScanOutputPrettyQuantized(results)
{
	var coldefs, quantizedcol, stream, bucketizer;

	coldefs = results.columns;
	quantizedcol = coldefs[coldefs.length - 1];
	mod_assert.equal(typeof (quantizedcol.aggr), 'string');
	bucketizer = results.bucketizers[quantizedcol.name];
	mod_assert.ok(bucketizer !== null);
	stream = process.stdout;

	results.rows.forEach(function (row) {
		var discrete_values = row.slice(0, coldefs.length - 1);
		var distr = row.slice(coldefs.length - 1);

		stream.write(discrete_values.join(', ') + '\n');
		printDistribution(stream, distr, bucketizer,
		    quantizedcol.name == '__dn_ts'); /* XXX */
		stream.write('\n');
	});
}

function printDistribution(stream, distr, bucketizer, omitleading)
{
	var total, count, normalized, dots;
	var bi, di, i, min;

	stream.write('           ');
	stream.write(
	    'value  ------------- Distribution ------------- count\n');

	if (distr.length === 0)
		return;

	total = 0;
	for (di = 0; di < distr.length; di++)
		total += distr[di][1];

	if (omitleading)
		bi = distr[0][0];
	else
		bi = 0;

	for (di = 0; di < distr.length + 1; bi++) {
		if (di == distr.length) {
			count = 0;
			di++;
		} else if (distr[di][0] == bi) {
			count = distr[di][1];
			di++;
		} else {
			count = 0;
		}

		normalized = Math.round(40 * count / total);
		dots = '';
		for (i = 0; i < normalized; i++)
			dots += '@';
		for (; i < 40; i++)
			dots += ' ';

		min = bucketizer.bucketMin(bi);
		stream.write(sprintf('%16s |%s %s\n',
		    min.toString(), dots, count));
	}
}

function cmdScanPrintCounters(c, showall)
{
	if (!showall) {
		if (c.aggr_nerr_nonnumeric !== 0) {
			console.error('warn: ignored %d non-numeric values',
			    c.aggr_nerr_nonnumeric);
		}

		return;
	}

	var width, fmt;
	mod_jsprim.forEachKey(c, function (name, value) {
		if (width === undefined || width < name.length)
			width = name.length;
	});
	fmt = '%-' + (width + 1) + 's  %d';
	mod_jsprim.forEachKey(c, function (name, value) {
		console.error(sprintf(fmt, name + ':', value));
	});
}

process.on('exit', function () { mod_assert.ok(dnDone); });

main();
